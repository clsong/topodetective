# packages ----------------------------------------------------------------
library(here)
library(Matrix)
library(compiler)
library(lars)
library(elasticnet)
library(tidyverse)
library(reshape2)
library(deSolve)
library(cowplot)
library(rEDM)
library(limSolve)
library(Matrix)
library(pspline)
library(Deriv)
library(deSolve)
library(readxl)
library(readr)
library(ggrepel)
library(corrplot)
library(DiagrammeR)
library(rlang)
# library(pomp)
# toolbox for ODEs --------------------------------------------------------
get_time_series <- function(eqns_per, times, state){
ODE_system <- function(t, state, parameters) {
# with(as.list(c(state,parameters)), {
#   dx1 <-  x1*eqn1_per(x1,x2,x3,x4)
#   dx2 <-  x2*eqn2_per(x1,x2,x3,x4)
#   dx3 <-  x3*eqn3_per(x1,x2,x3,x4)
#   dx4 <-  x4*eqn4_per(x1,x2,x3,x4)
#   list(c(dx1, dx2, dx3, dx4))
# })
with(as.list(c(state,parameters)), {
expression <- paste0("x", 1:num) %>%
paste(collapse=",")
res <- eval(parse(text=paste0("map_dbl(1:num, ~eqns_per[[.]](", expression, "))")))
list(res * state)
})
}
parameters <- c(a = 1)
out <- ode(y = state, times = times, func = ODE_system, parms = parameters)
dataset <- out[,2:(num+1)] %>% as.matrix()
colnames(dataset) = paste0('x', 1:num)
dataset
}
# toolbox for ODEs --------------------------------------------------------
generate_time_series <- function(eqns_per, times, state){
ODE_system <- function(t, state, parameters) {
# with(as.list(c(state,parameters)), {
#   dx1 <-  x1*eqn1_per(x1,x2,x3,x4)
#   dx2 <-  x2*eqn2_per(x1,x2,x3,x4)
#   dx3 <-  x3*eqn3_per(x1,x2,x3,x4)
#   dx4 <-  x4*eqn4_per(x1,x2,x3,x4)
#   list(c(dx1, dx2, dx3, dx4))
# })
with(as.list(c(state,parameters)), {
expression <- paste0("x", 1:num) %>%
paste(collapse=",")
res <- eval(parse(text=paste0("map_dbl(1:num, ~eqns_per[[.]](", expression, "))")))
list(res * state)
})
}
parameters <- c(a = 1)
out <- ode(y = state, times = times, func = ODE_system, parms = parameters)
dataset <- out[,2:(num+1)] %>% as.matrix()
colnames(dataset) = paste0('x', 1:num)
dataset
}
deqn_per <- function(eqns_per, dataset){
D <- function(i){
eqn <- eqns_per[[i]]
get_D <- function(eqn, ...){
Deriv(eqn)(...) %>%
as.matrix(nrow=1) %>%
t() %>%
as_tibble()
}
expression <- paste0("..", 1:num) %>%
paste(collapse=",")
eval(parse(text=paste0("pmap_dfr(as_tibble(dataset), ~get_D(eqn,", expression, "))"))) %>%
# pmap(~!!parse_expr("..1"))
# pmap_dfr(~get_D(!!parse_expr("eqn; ..1 ; ..2 ; ..3 ; ..4")))
mutate(time = row_number()) %>%
gather(Var2, J_analytic, -time) %>%
mutate(Var1 = paste0("x", i))
}
1:num %>%
map_dfr(~D(.x))
}
SolutionOde <- function(Sigma, r, N0, MaxTime = 2000){
alpha <- Sigma
parms <- list(r = r, alpha = alpha)
delta_t <- 0.01 #time step
time_step <- seq(0, MaxTime, by=delta_t) #sequence of time
model <- function(t,N,parms){ dN <- N * (parms$r + parms$alpha %*% N) + 1e-14; list(dN)}
sol <- ode(N0, time_step, model, parms, method="ode45")
return(sol)
}
fit_parameters <- function(data, topology, map = F){
if(map == T) pb$tick()$print()
num <- ncol(data)
log_diff <-
data %>%
as_tibble() %>%
map_dfr(~diff(log(.))) %>%
mutate(time_diff = diff(times[1:nrow(data)])) %>%
mutate(row = row_number()) %>%
gather(key, value, -time_diff, -row) %>%
mutate(value = value/time_diff) %>%
select(-time_diff) %>%
spread(key, value) %>%
select(-row)
abundance <- data %>%
as_tibble() %>%
{.[-nrow(.),]}
data_fit <- bind_cols(
log_diff,
abundance
) %>%
magrittr::set_colnames(c(paste0("dx", 1:num), paste0("x", 1:num)))
get_coef <- function(variable, data_fit, topology){
factors <- paste0("x", which(topology[variable, ] == 1))
formula <- as.formula(paste(paste0("dx", variable), "~", paste(factors, collapse="+")))
coef <- lm(formula, data= data_fit) %>%
broom::tidy() %>%
pull(estimate)
names(coef) <- c('r', factors)
if(length(coef) < num + 1){
zero <- rep(0, num + 1 - length(coef))
names(zero) <- setdiff(c('r', paste0("x", 1:num)), names(coef))
coef <- c(coef, zero)
}
coef %>%
enframe() %>%
arrange(name) %>%
select(-name)
}
1:num %>%
map_dfc(~get_coef(variable = ., data_fit, topology)) %>%
t() %>%
as_tibble() %>%
magrittr::set_colnames(c('r', paste0("a", 1:num)))
}
fit_simulation <- function(fitted, map = F){
if(map == T) pb$tick()$print()
Sigma <- fitted %>%
select(-r) %>%
as.matrix()
r <- fitted[,1] %>% unlist()
SolutionOde(Sigma, r = r, N0 = state, MaxTime = max(times)) %>%
as_tibble()
}
plot_interactions <- function(fitted, topology_ground){
bind_cols(
fitted %>%
select(-r) %>%
as.matrix() %>%
magrittr::set_colnames(1:4) %>%
magrittr::set_rownames(1:4) %>%
melt() %>%
rename(fit = value),
topology_ground %>%
as.matrix() %>%
magrittr::set_rownames(1:4) %>%
melt() %>%
rename(ground = value)
) %>%
ggplot(aes(ground, fit)) +
geom_point(size =2) +
geom_abline(slope=1,intercept = 0) +
theme_bw()+
theme(aspect.ratio = 1)
}
plot_topology <- function(fitted){
num <- ncol(fitted)-1
n <- tibble(
name = 1:num,
width = .2
) %>%
mutate(
id_external = name
)
e <- fitted %>%
select(-r) %>%
as.matrix() %>%
magrittr::set_colnames(1:num) %>%
magrittr::set_rownames(1:num) %>%
melt() %>%
rename(from = Var1,
to = Var2) %>%
mutate(color = if_else(value > 0, 'dodgerblue', 'firebrick2')) %>%
mutate(value = abs(2*value))
create_graph() %>%
add_nodes_from_table(
table = n
) %>%
add_edges_from_table(
table = e,
from_col = from,
to_col = to,
from_to_map = id_external
) %>%
copy_edge_attrs(
edge_attr_from = value,
edge_attr_to = penwidth
) %>%
render_graph(layout = "circular")
}
plot_fit_vs_simu <- function(dataset, times, simu, save = F, topology_label = F){
p <- bind_rows(
dataset %>%
as_tibble() %>%
mutate(time = times) %>%
gather(key, value, -time) %>%
mutate(type = "ground truth"),
simu %>%
gather(key, value, -time) %>%
mutate(type = "fitted")
) %>%
ggplot(aes(time, value, group = type, color = type)) +
geom_rect(aes(xmin = 0, xmax = times[split_end], ymin = -Inf, ymax = Inf),
fill = "#F9F4FB", alpha = 1, linetype = 0
) +
geom_rect(aes(xmin = times[split_end], xmax = max(times), ymin = -Inf, ymax = Inf),
fill = "#FEF7F2", alpha = 1, linetype = 0
) +
geom_line() +
facet_wrap(~key) +
scale_colour_manual(values = c("dodgerblue", "#FCBF4A")) +
theme_classic() +
theme(
aspect.ratio = 1
)
if(save == T){
ggsave(paste0(topology_label, '-fit_vs_simu.pdf'), p)
} else{
p
}
}
calculate_NRMSE <- function(sim, obs){
# (sim-obs)^2 %>%
#   mean() %>%
#   sqrt()/mean(obs)
sqrt(mean(sim-obs)^2)/(max(obs)-mean(obs))
}
evaluate_fit <- function(simu, dataset, map = F){
if(map == T) pb$tick()$print()
x <- simu %>%
filter(time %in% times) %>%
gather(key, value_simu, -time)
y <- dataset %>%
as_tibble() %>%
mutate(time = times) %>%
gather(key, value_ground, -time)
left_join(x,y) %>%
group_by(key) %>%
summarise(NRMSE = calculate_NRMSE(value_simu, value_ground),
correlation = cor(value_simu, value_ground)
)
}
generate_topology <- function(all_topologies, j){
offdiag <- all_topologies[j,] %>%
unlist()
topology <- matrix(NA, ncol = num, nrow = num)
topology[lower.tri(topology)] <- offdiag[1:(length(offdiag)/2)]
topology[upper.tri(topology)] <- offdiag[-(1:(length(offdiag)/2))]
diag(topology) <- rep(1, num)
topology
}
source("toolbox.r")
source("equations.r")
source("R/toolbox.r")
source("R/equations.r")
dataset <- get_time_series(eqns_per, times, state)
dataset <- generate_time_series(eqns_per, times, state)
dataset
plot_time_series(dataset)
dataset <- generate_time_series(eqns_per, times, state)
dataset
times
plot_time_series(dataset, times)
# fitted ------------------------------------------------------------------
split_begin <- floor(0.2 * nrow(dataset))
split_end <- floor(0.8 * nrow(dataset))
train <- dataset[1:split_end, ]
# topology <- matrix(1, nrow = ncol(dataset),  ncol = ncol(dataset)) #full
topology <- topology_ground
topology[topology != 0 ] <- 1
fitted <- fit_parameters(train, topology)
simu <- fit_simulation(fitted)
evaluate_fit(simu, dataset)
source("R/toolbox.r")
source("R/equations.r")
source("R/toolbox.r")
source("R/equations.r")
# get data ----------------------------------------------------------------
get_classic_dynamics("chaos")
source("R/equations.r")
# get data ----------------------------------------------------------------
get_classic_dynamics("chaos")
source("R/equations.r")
# get data ----------------------------------------------------------------
get_classic_dynamics("chaos")
source("R/equations.r")
# get data ----------------------------------------------------------------
get_classic_dynamics("chaos")
source("R/toolbox.r")
