fit_parameters(ts_species)
species_num <- ncol(ts_species) - 3
if (missing(topology_all)) {
topology_all <- rep(list(0:1), species_num) %>%
expand.grid() %>%
as_tibble() %>%
mutate(topology_label = row_number()) %>%
nest(topology = -topology_label)
}
reg_recipe <- ts_species %>%
select(-time, -species) %>%
{
recipe(log_change ~ ., data = .)
}
fitted_models <- topology_all %>%
mutate(workflow_fitted = map(topology, function(topology) {
if (sum(topology == 0) > 0) {
reg_recipe_local <- reg_recipe %>%
step_rm(paste0("x", which(topology == 0)))
} else{
reg_recipe_local <- reg_recipe
}
workflow() %>%
add_model(reg_model) %>%
add_recipe(reg_recipe_local) %>%
fit(data = ts_species)
}))
fitted_models %>%
mutate(
r2 = map_dbl(workflow_fitted, ~ glance(.)$r.squared),
estimate = map(workflow_fitted, tidy)
) %>%
unnest(estimate) %>%
select(topology, r2, term, estimate) %>%
pivot_wider(names_from = term, values_from = estimate) %>%
rename(r = `(Intercept)`)
#' Fit interaction matrix with given topology and intrinsic growth rates from time series
#'
#' @return A tibble with simulated time series of species abundances
#' @param Sigma Interaction matrix
#' @param r intrinsic growth rates
#' @param state_initial
#' @param time_range
#' @export
fit_parameters <- function(ts_species,
reg_model = choose_regression_model("linear"),
topology_all) {
species_num <- ncol(ts_species) - 3
if (missing(topology_all)) {
topology_all <- rep(list(0:1), species_num) %>%
expand.grid() %>%
as_tibble() %>%
mutate(topology_label = row_number()) %>%
nest(topology = -topology_label)
}
reg_recipe <- ts_species %>%
select(-time, -species) %>%
{
recipe(log_change ~ ., data = .)
}
# df_split <- initial_time_split(ts_species, prop = 3 / 4)
# df_train <- training(df_split)
# df_test <- testing(df_split)
fitted_models <- topology_all %>%
mutate(workflow_fitted = map(topology, function(topology) {
if (sum(topology == 0) > 0) {
reg_recipe_local <- reg_recipe %>%
step_rm(paste0("x", which(topology == 0)))
} else{
reg_recipe_local <- reg_recipe
}
workflow() %>%
add_model(reg_model) %>%
add_recipe(reg_recipe_local) %>%
fit(data = ts_species)
}))
fitted_models %>%
mutate(
r2 = map_dbl(workflow_fitted, ~ glance(.)$r.squared),
estimate = map(workflow_fitted, tidy)
) %>%
unnest(estimate) %>%
select(topology, r2, term, estimate) %>%
pivot_wider(names_from = term, values_from = estimate) %>%
rename(r = `(Intercept)`)
}
fit_parameters(ts_species)
ts_tidy %>%
group_split(species) %>%
map(fit_parameters)
#' Fit interaction matrix with given topology and intrinsic growth rates from time series
#'
#' @return A tibble with simulated time series of species abundances
#' @param Sigma Interaction matrix
#' @param r intrinsic growth rates
#' @param state_initial
#' @param time_range
#' @export
fit_parameters <- function(ts_species,
reg_model = choose_regression_model("linear"),
topology_all) {
species_num <- ncol(ts_species) - 3
if (missing(topology_all)) {
topology_all <- rep(list(0:1), species_num) %>%
expand.grid() %>%
as_tibble() %>%
mutate(topology_label = row_number()) %>%
nest(topology = -topology_label)
}
reg_recipe <- ts_species %>%
select(-time, -species) %>%
{
recipe(log_change ~ ., data = .)
}
# df_split <- initial_time_split(ts_species, prop = 3 / 4)
# df_train <- training(df_split)
# df_test <- testing(df_split)
fitted_models <- topology_all %>%
mutate(workflow_fitted = map(topology, function(topology) {
if (sum(topology == 0) > 0) {
reg_recipe_local <- reg_recipe %>%
step_rm(paste0("x", which(topology == 0)))
} else{
reg_recipe_local <- reg_recipe
}
workflow() %>%
add_model(reg_model) %>%
add_recipe(reg_recipe_local) %>%
fit(data = ts_species)
}))
fitted_models %>%
mutate(
r2 = map_dbl(workflow_fitted, ~ glance(.)$r.squared),
estimate = map(workflow_fitted, tidy)
) %>%
unnest(estimate) %>%
select(topology_label, topology, r2, term, estimate) %>%
pivot_wider(names_from = term, values_from = estimate) %>%
rename(r = `(Intercept)`)
}
fitted_models <- ts_tidy %>%
group_split(species) %>%
map(fit_parameters)
fitted_models
fitted_models %>%
bind_rows(.id = 'species')
ts_tidy %>%
group_split(species) %>%
bind_rows(.id = 'species')
fitted_models <- ts_tidy %>%
group_split(species) %>%
map(fit_parameters) %>%
bind_rows(.id = 'species') %>%
mutate(species = paste0("x", species))
fitted_models
library(InferInteractions)
get_classic_dynamics("chaos") # choose a dynamic
ts <- generate_time_series(eqns_per, time_range, state_initial, species_num) # simulate a dynamic
plot_time_series(ts)
ts_tidy <- preprocess_ts(ts)
ts_species <- ts_tidy %>%
filter(species == 'x1')
reg_model <- choose_regression_model("linear")
fitted_models <- ts_tidy %>%
group_split(species) %>%
map(fit_parameters) %>%
bind_rows(.id = 'species') %>%
mutate(species = paste0("x", species))
library(InferInteractions)
library(InferInteractions)
get_classic_dynamics("chaos") # choose a dynamic
ts <- generate_time_series(eqns_per, time_range, state_initial, species_num) # simulate a dynamic
plot_time_series(ts)
ts_tidy <- preprocess_ts(ts)
ts_species <- ts_tidy %>%
filter(species == 'x1')
reg_model <- choose_regression_model("linear")
fitted_models <- ts_tidy %>%
group_split(species) %>%
map(fit_interaction_parameters) %>%
bind_rows(.id = 'species') %>%
mutate(species = paste0("x", species))
fitted_models
fitted_models %>%
ggplot(aes(topology_label, r2, color = speices)) +
geom_point()
fitted_models %>%
ggplot(aes(topology_label, r2, color = species)) +
geom_point()
theme_set(jtools::theme_nice())
library(InferInteractions)
get_classic_dynamics("chaos") # choose a dynamic
ts <- generate_time_series(eqns_per, time_range, state_initial, species_num) # simulate a dynamic
plot_time_series(ts)
ts_tidy <- preprocess_ts(ts)
ts_species <- ts_tidy %>%
filter(species == 'x1')
reg_model <- choose_regression_model("linear")
fitted_models <- ts_tidy %>%
group_split(species) %>%
map(fit_interaction_parameters) %>%
bind_rows(.id = 'species') %>%
mutate(species = paste0("x", species))
fitted_models %>%
ggplot(aes(topology_label, r2, color = species)) +
geom_point()
fitted_models %>%
ggplot(aes(forcats::fct_reorder(topology_label, r2), r2, color = species)) +
geom_point()
fitted_models %>%
mutate(topology_label =as.factor(topology_label)) %>%
ggplot(aes(forcats::fct_reorder(topology_label, r2), r2, color = species)) +
geom_point()
topology_ground
fitted_models
fitted_models %>%
group_by(species) %>%
sample_n(1)
fitted_models %>%
filter(r2 > .9) %>%
group_by(species) %>%
sample_n(1)
#' Fit interaction matrix with given topology and intrinsic growth rates from time series
#'
#' @return A tibble with simulated time series of species abundances
#' @param Sigma Interaction matrix
#' @param r intrinsic growth rates
#' @param state_initial
#' @param time_range
#' @export
fit_interaction_parameters <- function(ts_species,
reg_model = choose_regression_model("linear"),
topology_all) {
species_num <- ncol(ts_species) - 3
if (missing(topology_all)) {
topology_all <- rep(list(0:1), species_num) %>%
expand.grid() %>%
as_tibble() %>%
mutate(topology_label = row_number()) %>%
nest(topology = -topology_label)
}
reg_recipe <- ts_species %>%
select(-time, -species) %>%
{
recipe(log_change ~ ., data = .)
}
# df_split <- initial_time_split(ts_species, prop = 3 / 4)
# df_train <- training(df_split)
# df_test <- testing(df_split)
fitted_models <- topology_all %>%
mutate(workflow_fitted = map(topology, function(topology) {
if (sum(topology == 0) > 0) {
reg_recipe_local <- reg_recipe %>%
step_rm(paste0("x", which(topology == 0)))
} else{
reg_recipe_local <- reg_recipe
}
workflow() %>%
add_model(reg_model) %>%
add_recipe(reg_recipe_local) %>%
fit(data = ts_species)
}))
fitted_models %>%
mutate(
r2 = map_dbl(workflow_fitted, ~ glance(.)$r.squared),
estimate = map(workflow_fitted, tidy)
) %>%
unnest(estimate) %>%
select(topology, r2, term, estimate) %>%
pivot_wider(names_from = term, values_from = estimate) %>%
rename(r = `(Intercept)`)
}
fitted_models <- ts_tidy %>%
group_split(species) %>%
map(fit_interaction_parameters) %>%
bind_rows(.id = 'species') %>%
mutate(species = paste0("x", species))
fitted_models %>%
filter(r2 > .9) %>%
group_by(species) %>%
sample_n(1)
fitted_model <- fitted_models %>%
filter(r2 > .9) %>%
group_by(species) %>%
sample_n(1)
Sigma <- fitted_model %>%
select(starts_with("x")) %>%
as.matrix()
Sigma
fitted_model <- fitted_models %>%
filter(r2 > .9) %>%
group_by(species) %>%
sample_n(1) %>%
ungroup()
Sigma <- fitted_model %>%
select(starts_with("x")) %>%
as.matrix()
Sigma
fitted_model
#' Fit interaction matrix with given topology and intrinsic growth rates from time series
#'
#' @return A tibble with simulated time series of species abundances
#' @param Sigma Interaction matrix
#' @param r intrinsic growth rates
#' @param state_initial
#' @param time_range
#' @export
fit_interaction_parameters <- function(ts_species,
reg_model = choose_regression_model("linear"),
topology_all) {
species_num <- ncol(ts_species) - 3
if (missing(topology_all)) {
topology_all <- rep(list(0:1), species_num) %>%
expand.grid() %>%
as_tibble() %>%
mutate(topology_label = row_number()) %>%
nest(topology = -topology_label)
}
reg_recipe <- ts_species %>%
select(-time, -species) %>%
{
recipe(log_change ~ ., data = .)
}
# df_split <- initial_time_split(ts_species, prop = 3 / 4)
# df_train <- training(df_split)
# df_test <- testing(df_split)
fitted_models <- topology_all %>%
mutate(workflow_fitted = map(topology, function(topology) {
if (sum(topology == 0) > 0) {
reg_recipe_local <- reg_recipe %>%
step_rm(paste0("x", which(topology == 0)))
} else{
reg_recipe_local <- reg_recipe
}
workflow() %>%
add_model(reg_model) %>%
add_recipe(reg_recipe_local) %>%
fit(data = ts_species)
}))
fitted_models %>%
mutate(
R2 = map_dbl(workflow_fitted, ~ glance(.)$r.squared),
estimate = map(workflow_fitted, tidy)
) %>%
unnest(estimate) %>%
select(topology, R2, term, estimate) %>%
pivot_wider(names_from = term, values_from = estimate) %>%
rename(r = `(Intercept)`)
}
source("~/Dropbox (Personal)/Research_PostDoc/09_package_InferInteractions/main.R")
theme_set(jtools::theme_nice())
library(InferInteractions)
get_classic_dynamics("chaos") # choose a dynamic
ts <- generate_time_series(eqns_per, time_range, state_initial, species_num) # simulate a dynamic
plot_time_series(ts)
ts_tidy <- preprocess_ts(ts)
theme_set(jtools::theme_nice())
library(InferInteractions)
get_classic_dynamics("chaos") # choose a dynamic
ts <- generate_time_series(eqns_per, time_range, state_initial, species_num) # simulate a dynamic
plot_time_series(ts)
ts_tidy <-
reg_model <- choose_regression_model("linear")
fitted_models <- ts %>%
preprocess_ts() %>%
group_split(species) %>%
map(fit_interaction_parameters) %>%
bind_rows(.id = 'species') %>%
mutate(species = paste0("x", species))
fitted_model <- fitted_models %>%
filter(R2 > .9) %>%
group_by(species) %>%
sample_n(1) %>%
ungroup()
#' Fit interaction matrix with given topology and intrinsic growth rates from time series
#'
#' @return A tibble with simulated time series of species abundances
#' @param Sigma Interaction matrix
#' @param r intrinsic growth rates
#' @param state_initial
#' @param time_range
#' @export
fit_interaction_parameters <- function(ts_species,
reg_model = choose_regression_model("linear"),
topology_all) {
species_num <- ncol(ts_species) - 3
if (missing(topology_all)) {
topology_all <- rep(list(0:1), species_num) %>%
expand.grid() %>%
as_tibble() %>%
mutate(topology_label = row_number()) %>%
nest(topology = -topology_label)
}
reg_recipe <- ts_species %>%
select(-time, -species) %>%
{
recipe(log_change ~ ., data = .)
}
# df_split <- initial_time_split(ts_species, prop = 3 / 4)
# df_train <- training(df_split)
# df_test <- testing(df_split)
fitted_models <- topology_all %>%
mutate(workflow_fitted = map(topology, function(topology) {
if (sum(topology == 0) > 0) {
reg_recipe_local <- reg_recipe %>%
step_rm(paste0("x", which(topology == 0)))
} else{
reg_recipe_local <- reg_recipe
}
workflow() %>%
add_model(reg_model) %>%
add_recipe(reg_recipe_local) %>%
fit(data = ts_species)
}))
fitted_models %>%
mutate(
R2 = map_dbl(workflow_fitted, ~ glance(.)$r.squared),
estimate = map(workflow_fitted, tidy)
) %>%
unnest(estimate) %>%
select(topology, R2, term, estimate) %>%
pivot_wider(names_from = term, values_from = estimate) %>%
rename(r = `(Intercept)`)
}
fitted_models <- ts %>%
preprocess_ts() %>%
group_split(species) %>%
map(fit_interaction_parameters) %>%
bind_rows(.id = 'species') %>%
mutate(species = paste0("x", species))
fitted_model <- fitted_models %>%
filter(R2 > .9) %>%
group_by(species) %>%
sample_n(1) %>%
ungroup()
topology_ground
fitted_model
Sigma <- fitted_model %>%
select(starts_with("x")) %>%
as.matrix()
r <- fitted_model %>%
pull(r) %>%
unlist()
r
fitted_model
generate_time_series_LV(
Sigma= Sigma,
r = r,
N0 = state_initial,
MaxTime = max(time_range)) %>%
as_tibble()
#' Simulated time series of species abundances
#'
#' @return A tibble with simulated time series of species abundances
#' @param Sigma Interaction matrix
#' @param r intrinsic growth rates
#' @param state_initial
#' @param time_range
#' @export
generate_time_series_LV <- function(Sigma, r, state_initial, time_range) {
alpha <- Sigma
parms <- list(r = r, alpha = alpha)
delta_t <- 0.01 # time step
time_step <- seq(0, max(time_range), by = delta_t) # sequence of time
model <- function(t, N, parms) {
dN <- N * (parms$r + parms$alpha %*% N) + 1e-14
list(dN)
}
ode(state_initial, time_step, model, parms, method = "ode45") %>%
as_tibble()
}
generate_time_series_LV(
Sigma= Sigma,
r = r,
state_initial = state_initial,
time_range = time_range)
Sigma
Sigma <- fitted_model %>%
select(starts_with("x")) %>%
replace_na(0) %>%
as.matrix()
fitted_model %>%
select(starts_with("x")) %>%
replace_na(0)
fitted_model %>%
select(starts_with("x")) %>%
mutate_all(replace_na(0))
fitted_model %>%
select(starts_with("x")) %>%
mutate_all(replace_na(., 0))
Sigma <- fitted_model %>%
select(starts_with("x")) %>%
mutate(
across(everything(), ~replace_na(.x, 0))
) %>%
as.matrix()
Sigma
Sigma <- fitted_model %>%
select(starts_with("x")) %>%
mutate(
across(everything(), ~replace_na(.x, 0))
) %>%
as.matrix()
r <- fitted_model %>%
pull(r) %>%
unlist()
generate_time_series_LV(
Sigma= Sigma,
r = r,
state_initial = state_initial,
time_range = time_range)
library(InferInteractions)
