library(tidymodels)  # for the parsnip package, along with the rest of tidymodels
# Helper packages
library(readr)       # for importing data
library(broom.mixed) # for converting bayesian models to tidy tibbles
library(dotwhisker)  # for visualizing regression results
urchins <-
# Data were assembled for a tutorial
# at https://www.flutterbys.com.au/stats/tut/tut7.5a.html
read_csv("https://tidymodels.org/start/models/urchins.csv") %>%
# Change the names to be a little more verbose
setNames(c("food_regime", "initial_volume", "width")) %>%
# Factors are very helpful for modeling, so we convert one column
mutate(food_regime = factor(food_regime, levels = c("Initial", "Low", "High")))
urchins
ggplot(urchins,
aes(x = initial_volume,
y = width,
group = food_regime,
col = food_regime)) +
geom_point() +
geom_smooth(method = lm, se = FALSE) +
scale_color_viridis_d(option = "plasma", end = .7)
linear_reg() %>%
set_engine("lm")
lm_mod <- linear_reg() %>%
set_engine("lm")
lm_fit <-
lm_mod %>%
fit(width ~ initial_volume * food_regime, data = urchins)
lm_fit
lm_fit
lm_fit
tidy(lm_fit) %>%
dwplot(dot_args = list(size = 2, color = "black"),
whisker_args = list(color = "black"),
vline = geom_vline(xintercept = 0, colour = "grey50", linetype = 2))
new_points
new_points <- expand.grid(initial_volume = 20,
food_regime = c("Initial", "Low", "High"))
new_points
mean_pred <- predict(lm_fit, new_data = new_points)
mean_pred
skimr::skim(mtcars, dest, carrier)
install.packages("skimr")
skimr::skim(mtcars, dest, carrier)
skimr::skim(mtcars, dest, carrier)
mtcars
mtcarslibrary(tidymodels)      # for the recipes package, along with the rest of tidymodels
# Helper packages
library(nycflights13)    # for flight data
library(skimr)           # for variable summaries
library(tidymodels)      # for the recipes package, along with the rest of tidymodels
# Helper packages
library(nycflights13)    # for flight data
library(skimr)           # for variable summaries
install.packages("nycflights13")
library(tidymodels)      # for the recipes package, along with the rest of tidymodels
# Helper packages
library(nycflights13)    # for flight data
library(skimr)           # for variable summaries
flight_data <-
flights %>%
mutate(
# Convert the arrival delay to a factor
arr_delay = ifelse(arr_delay >= 30, "late", "on_time"),
arr_delay = factor(arr_delay),
# We will use the date (not date-time) in the recipe below
date = lubridate::as_date(time_hour)
) %>%
# Include the weather data
inner_join(weather, by = c("origin", "time_hour")) %>%
# Only retain the specific columns we will use
select(dep_time, flight, origin, dest, air_time, distance,
carrier, date, arr_delay, time_hour) %>%
# Exclude missing data
na.omit() %>%
# For creating models, it is better to have qualitative columns
# encoded as factors (instead of character strings)
mutate_if(is.character, as.factor)
flight_data
flight_data %>%
skimr::skim(dest, carrier)
flights_rec <-
recipe(arr_delay ~ ., data = train_data)
# Fix the random numbers by setting the seed
# This enables the analysis to be reproducible when random numbers are used
set.seed(222)
# Put 3/4 of the data into the training set
data_split <- initial_split(flight_data, prop = 3/4)
# Create data frames for the two sets:
train_data <- training(data_split)
test_data  <- testing(data_split)
flights_rec <-
recipe(arr_delay ~ ., data = train_data)
flights_rec
flights_rec <-
recipe(arr_delay ~ ., data = train_data) %>%
update_role(flight, time_hour, new_role = "ID") %>%
step_date(date, features = c("dow", "month")) %>%
step_holiday(date,
holidays = timeDate::listHolidays("US"),
keep_original_cols = FALSE)
flights_rec
summary(flights_rec)
flights_rec <-
recipe(arr_delay ~ ., data = train_data) %>%
update_role(flight, time_hour, new_role = "ID") %>%
step_date(date, features = c("dow", "month")) %>%
step_holiday(date,
holidays = timeDate::listHolidays("US"),
keep_original_cols = FALSE) %>%
step_dummy(all_nominal_predictors()) %>%
step_zv(all_predictors())
lr_mod <-
logistic_reg() %>%
set_engine("glm")
flights_wflow <-
workflow() %>%
add_model(lr_mod) %>%
add_recipe(flights_rec)
flights_wflow <-
workflow() %>%
add_model(lr_mod) %>%
add_recipe(flights_rec)
flights_wflow
flights_fit <-
flights_wflow %>%
fit(data = train_data)
library(tidymodels) # for the rsample package, along with the rest of tidymodels
# Helper packages
library(modeldata)  # for the cells data
data(cells, package = "modeldata")
cells
set.seed(123)
cell_split <- initial_split(cells %>% select(-case),
strata = class)
rf_mod <-
rand_forest(trees = 1000) %>%
set_engine("ranger") %>%
set_mode("classification")
cell_train <- training(cell_split)
cell_test  <- testing(cell_split)
nrow(cell_train)
#> [1] 1515
nrow(cell_train)/nrow(cells)
set.seed(234)
rf_fit <-
rf_mod %>%
fit(class ~ ., data = cell_train)
rf_fit
install.packages("ranger")
set.seed(234)
rf_fit <-
rf_mod %>%
fit(class ~ ., data = cell_train)
rf_fit
library(tidymodels)
# Helper packages
library(readr)       # for importing data
library(vip)         # for variable importance plots
install.packages("vip")
library(tidymodels)
library(readr)
hotels <-
read_csv('https://tidymodels.org/start/case-study/hotels.csv') %>%
mutate_if(is.character, as.factor)
dim(hotels)
#> [1] 50000    23
hotels
set.seed(123)
splits      <- initial_split(hotels, strata = children)
hotel_other <- training(splits)
hotel_test  <- testing(splits)
set.seed(234)
val_set <- validation_split(hotel_other,
strata = children,
prop = 0.80)
val_set
lr_mod <-
logistic_reg(penalty = tune(), mixture = 1) %>%
set_engine("glmnet")
# packages ----------------------------------------------------------------
library(deSolve)
library(magrittr)
library(purrr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(jtools)
library(rsample)
library(tibble)
library(broom)
source("R/equations.r")
source("R/solve_ODEs.R")
source("R/fit_trajectory.R")
# packages ----------------------------------------------------------------
library(deSolve)
library(magrittr)
library(purrr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(jtools)
library(rsample)
library(tibble)
library(broom)
library(InferInteractions)
get_classic_dynamics("chaos") # choose a dynamic
ts <- generate_time_series(eqns_per, time_range, state_initial, species_num) # simulate a dynamic
plot_time_series(ts)
# fitted ------------------------------------------------------------------
ts_split <- initial_time_split(ts, prop = 3/4)
train_ts <- training(ts_split)
test_ts  <- testing(ts_split)
topology <- topology_ground
topology[topology != 0 ] <- 1
fitted <- fit_parameters(train_ts, topology)
data <- train_ts
species_num <- ncol(data) - 1
log_diff <- data %>%
mutate_at(vars(matches("x")), log) %>%
mutate_all(~.-lag(.)) %>%
drop_na() %>%
mutate(row = row_number()) %>%
gather(key, dlogN, -time, -row) %>%
mutate(dlogN_dt = dlogN/time) %>%
select(-time, -dlogN) %>%
spread(key, dlogN_dt) %>%
select(-row)
data %>%
gather(species, abundance, -time)
data %>%
gather(species, abundance, -time) %>%
augment(log_diff)
data %>%
gather(species, abundance, -time) %>%
left_join(log_diff)
log_diff
log_diff <- data %>%
mutate_at(vars(matches("x")), log) %>%
mutate_all(~.-lag(.)) %>%
drop_na() %>%
mutate(row = row_number()) %>%
gather(key, dlogN, -time, -row) %>%
mutate(dlogN_dt = dlogN/time) %>%
select(-time, -dlogN) %>%
spread(key, dlogN_dt) %>%
select(-row) %>%
mutate(time = data$time[-1])
log_diff
data %>%
gather(species, abundance, -time) %>%
left_join(log_diff)
log_diff %>%
gather(species, abundance,-time)
log_diff %>%
gather(species, log_change, -time)
log_diff %>%
gather(species, log_change, -time) %>%
left_join(data)
log_diff %>%
gather(species, log_change, -time) %>%
left_join(data)
df <- log_diff %>%
gather(species, log_change, -time) %>%
left_join(data) %>%
group_by(species)
df
recipe(log_change ~ ., data = df)
library(recipes)
library(devtools)
usethis("recipes")
use_package("recipes")
recipe(log_change ~ ., data = df)
df
recipe(log_change ~ ., data = df) %>%
update_role(time, new_role = "ID")
lm_mod <-
linear_reg() %>%
set_engine("lm")
library(parsnip)
use_package("parsnip")
lm_mod <-
linear_reg() %>%
set_engine("lm")
lm_mod <-
linear_reg() %>%
set_engine("lm")
df_rec <- recipe(log_change ~ ., data = df) %>%
update_role(time, new_role = "ID")
flights_wflow <-
workflow() %>%
add_model(lm_mod) %>%
add_recipe(df_rec)
library(workflows)
use_package("workflows")
lm_mod <-
linear_reg() %>%
set_engine("lm")
df_rec <- recipe(log_change ~ ., data = df) %>%
update_role(time, new_role = "ID")
df_wflow <-
workflow() %>%
add_model(lm_mod) %>%
add_recipe(df_rec)
df_wflow %>%
fit(data = df)
species_num <- ncol(ts) - 1
ts_split <- initial_time_split(ts, prop = 3/4)
train_ts <- training(ts_split)
test_ts  <- testing(ts_split)
log_diff <- ts %>%
mutate_at(vars(matches("x")), log) %>%
mutate_all(~.-lag(.)) %>%
drop_na() %>%
mutate(row = row_number()) %>%
gather(key, dlogN, -time, -row) %>%
mutate(dlogN_dt = dlogN/time) %>%
select(-time, -dlogN) %>%
spread(key, dlogN_dt) %>%
select(-row) %>%
mutate(time = ts$time[-1])
log_diff %>%
gather(species, log_change, -time) %>%
left_join(train_ts) %>%
group_by(species)
#' Transform a time series data into a tibble that is ready to fit the regression
#'
#' @return A tibble with log change of species abundance with original abundance
#' @param ts Time series data
#' @export
preprocess_ts <- function(ts){
log_diff <- ts %>%
mutate_at(vars(matches("x")), log) %>%
mutate_all(~.-lag(.)) %>%
drop_na() %>%
mutate(row = row_number()) %>%
gather(key, dlogN, -time, -row) %>%
mutate(dlogN_dt = dlogN/time) %>%
select(-time, -dlogN) %>%
spread(key, dlogN_dt) %>%
select(-row) %>%
mutate(time = ts$time[-1])
log_diff %>%
gather(species, log_change, -time) %>%
left_join(train_ts) %>%
group_by(species)
}
df <- preprocess_ts(ts)
initial_time_split
ts_split <- initial_time_split(df, prop = 3/4)
df <- preprocess_ts(ts)
df_split <- initial_time_split(df, prop = 3/4)
train <- training(df_split)
test  <- testing(df_split)
train
test
#' Transform a time series data into a tibble that is ready to fit the regression
#'
#' @return A tibble with log change of species abundance with original abundance
#' @param ts Time series data
#' @export
preprocess_ts <- function(ts){
log_diff <- ts %>%
mutate_at(vars(matches("x")), log) %>%
mutate_all(~.-lag(.)) %>%
drop_na() %>%
mutate(row = row_number()) %>%
gather(key, dlogN, -time, -row) %>%
mutate(dlogN_dt = dlogN/time) %>%
select(-time, -dlogN) %>%
spread(key, dlogN_dt) %>%
select(-row) %>%
mutate(time = ts$time[-1])
log_diff %>%
gather(species, log_change, -time) %>%
left_join(train_ts)
}
species_num <- ncol(ts) - 1
df <- preprocess_ts(ts)
df_split <- initial_time_split(df, prop = 3/4)
train <- training(df_split)
test  <- testing(df_split)
train
df_rec <- recipe(log_change ~ ., data = df) %>%
update_role(time, new_role = "ID")
df_wflow <-
workflow() %>%
add_model(lm_mod) %>%
add_recipe(df_rec)
df_rec <- recipe(log_change ~ ., data = train) %>%
update_role(time, new_role = "ID")
df_wflow <-
workflow() %>%
add_model(lm_mod) %>%
add_recipe(df_rec)
df_wflow %>%
fit(data = df) %>%
predict(test)
df
df <- preprocess_ts(ts) %>%
group_split(species)
df
df <- df[[1]]
df_split <- initial_time_split(df, prop = 3/4)
train <- training(df_split)
test  <- testing(df_split)
lm_mod <-
linear_reg() %>%
set_engine("lm")
df_rec <- recipe(log_change ~ ., data = train) %>%
update_role(time, new_role = "ID")
df_wflow <-
workflow() %>%
add_model(lm_mod) %>%
add_recipe(df_rec)
df_wflow %>%
fit(data = df) %>%
predict(test)
df_rec <- recipe(log_change ~ ., data = train) %>%
update_role(time, species, new_role = "ID")
df_wflow <-
workflow() %>%
add_model(lm_mod) %>%
add_recipe(df_rec)
df_wflow %>%
fit(data = df) %>%
predict(test)
df
df_split <- initial_time_split(df, prop = 3/4)
train <- training(df_split)
test  <- testing(df_split)
lm_mod <-
linear_reg() %>%
set_engine("lm")
df_rec <- recipe(log_change ~ ., data = train) %>%
update_role(time, species, new_role = "ID")
df_rec
df_wflow <-
workflow() %>%
add_model(lm_mod) %>%
add_recipe(df_rec)
df_wflow %>%
fit(data = train) %>%
predict(test)
df_wflow %>%
fit(data = train)
test
train
test
train <- training(df_split)
test  <- testing(df_split)
test
species_num <- ncol(ts) - 1
df <- preprocess_ts(ts) %>%
group_split(species)
df <- df[[1]]
df_split <- initial_time_split(df, prop = 3/4)
train <- training(df_split)
test  <- testing(df_split)
test
df_split
train <- training(df_split)
train
test
library(InferInteractions)
get_classic_dynamics("chaos") # choose a dynamic
ts <- generate_time_series(eqns_per, time_range, state_initial, species_num) # simulate a dynamic
plot_time_series(ts)
ts_split <- initial_time_split(ts, prop = 3/4)
train_ts <- training(ts_split)
test_ts  <- testing(ts_split)
species_num <- ncol(ts) - 1
df <- preprocess_ts(ts) %>%
group_split(species)
df <- df[[1]]
#' Transform a time series data into a tibble that is ready to fit the regression
#'
#' @return A tibble with log change of species abundance with original abundance
#' @param ts Time series data
#' @export
preprocess_ts <- function(ts){
log_diff <- ts %>%
mutate_at(vars(matches("x")), log) %>%
mutate_all(~.-lag(.)) %>%
drop_na() %>%
mutate(row = row_number()) %>%
gather(key, dlogN, -time, -row) %>%
mutate(dlogN_dt = dlogN/time) %>%
select(-time, -dlogN) %>%
spread(key, dlogN_dt) %>%
select(-row) %>%
mutate(time = ts$time[-1])
log_diff %>%
gather(species, log_change, -time) %>%
left_join(train_ts)
}
species_num <- ncol(ts) - 1
df <- preprocess_ts(ts) %>%
group_split(species)
df <- df[[1]]
df_split <- initial_time_split(df, prop = 3/4)
train <- training(df_split)
test  <- testing(df_split)
test
df
df_split <- initial_time_split(df, prop = 3/4)
train <- training(df_split)
test  <- testing(df_split)
train
test  <- testing(df_split)
test
